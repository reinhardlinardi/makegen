/* 
   makegen.cpp
   > g++ makegen.cpp -o makegen -std=c++11
*/

#include <iostream>
#include <fstream>
#include <string>
#include <regex>


const std::string MAKEFILE = "Makefile";
const std::string CONFIG = "makegen.conf";
const std::string DELIMITER = "=";


std::string LANGUAGE; // c or c++
std::string STANDARD; // e.g. c99, c++11

std::string SRC_PATH; // source path
std::string HEADER_PATH; // header path (-I)

std::string COMPILER; // e.g. gcc, g++, clang, clang++
bool DEBUG; // -g
bool OPTIMIZE; // -O2
std::string COMPILER_FLAGS; // e.g. -Wall
std::string LINKER_FLAGS; // e.g. -lm

std::string OBJECT_PATH; // object files path
std::string EXE_PATH; // executable path
std::string EXE_NAME; // executable name


std::string trim_whitespace(std::string s) {
    return std::regex_replace(std::regex_replace(s, std::regex("^\\s+"), ""), std::regex("\\s+$"), "");
}

std::string format_whitespace(std::string s) {
    return std::regex_replace(s, std::regex("\\s+"), " ");
}

std::string format_path(std::string s) {
    return std::regex_replace(s, std::regex("/$"), "");
}

void parse_language(std::string val) {
    LANGUAGE = val == "c" || val == "c++"? val : "";
    if(LANGUAGE == "") {
        std::cout << std::endl << "error: LANGUAGE invalid";
        exit(1);
    }
}

void set_standard(std::string val) {
    COMPILER_FLAGS += val == ""? "" : " -std=" + val;
}

void set_src_path(std::string val) {
    SRC_PATH = val == ""? "src" : format_path(val);
}

void set_header_path(std::string val) {
    HEADER_PATH = format_path(val);
    COMPILER_FLAGS += HEADER_PATH == ""? "" : " -I" + HEADER_PATH;
}

void set_compiler(std::string val) {
    COMPILER = val == ""? (LANGUAGE == "c"? "gcc" : "g++") : val;
}

void set_debug(std::string val) {
    DEBUG = val == "false"? false : true;
    COMPILER_FLAGS += DEBUG? " -g" : "";
}

void set_optimize(std::string val) {
    OPTIMIZE = val == "true"? true : false;
    COMPILER_FLAGS += OPTIMIZE? " -O2" : "";
}

void set_compiler_flags(std::string val) {
    COMPILER_FLAGS += val == ""? "" : " " + val;
}

void set_linker_flags(std::string val) {
	LINKER_FLAGS = val;
}

void set_object_path(std::string val) {
    OBJECT_PATH = val == ""? "obj" : format_path(val);
}

void set_exe_path(std::string val) {
    EXE_PATH = val == ""? "bin" : format_path(val);
}

void set_exe_name(std::string val) {
    EXE_NAME = val == ""? "main" : val;
}

void read_config() {
    std::cout << "Reading config file ...";

    std::fstream file;
    file.open(CONFIG, std::fstream::in);
    if(file.fail()) {    
        std::cout << " file missing or failed to open file.";
        exit(1);
    }

    std::string line;
    while(getline(file, line)) {
        size_t delimiter_idx = line.find(DELIMITER);

        if(delimiter_idx != line.npos) {
            std::string name = line.substr(0, delimiter_idx);
            name = trim_whitespace(name);

            std::string val = line.substr(delimiter_idx+1, line.length()-1);
            val = format_whitespace(trim_whitespace(val));

            if(name == "LANGUAGE") parse_language(val);
            else if(name == "STANDARD") set_standard(val);
            else if(name == "SRC_PATH") set_src_path(val);
            else if(name == "HEADER_PATH") set_header_path(val);
            else if(name == "COMPILER") set_compiler(val);
            else if(name == "DEBUG") set_debug(val);
            else if(name == "OPTIMIZE") set_optimize(val);
            else if(name == "COMPILER_FLAGS") set_compiler_flags(val);
            else if(name == "LINKER_FLAGS") set_linker_flags(val);
            else if(name == "OBJECT_PATH") set_object_path(val);
            else if(name == "EXE_PATH") set_exe_path(val);
            else if(name == "EXE_NAME") set_exe_name(val);
        }
    }

    COMPILER_FLAGS = trim_whitespace(COMPILER_FLAGS);
    file.close();
}

void generate_makefile() {
    std::cout << std::endl << "Generating makefile ...";

    std::fstream file;
    file.open(MAKEFILE, std::fstream::out);
    if(file.fail()) {
        std::cout << " failed to open file.";
        exit(1);
    }

    std::string EXT = LANGUAGE == "c"? "c" : "cpp";

    file << "# --- Autogenerated by makegen ---" << std::endl << std::endl;

    file << "# Source" << std::endl;
    file << "SRC_PATH := " << SRC_PATH << std::endl << std::endl;

    file << "# Build" << std::endl;
    file << "COMPILER := " << COMPILER << std::endl;
    file << "COMPILER_FLAGS := " << COMPILER_FLAGS << std::endl;
    file << "LINKER_FLAGS := " << LINKER_FLAGS << std::endl << std::endl;

    file << "# Output" << std::endl;
    file << "OBJECT_PATH := " << OBJECT_PATH << std::endl;
    file << "EXE_PATH := " << EXE_PATH << std::endl;
    file << "EXE_NAME := " << EXE_NAME << std::endl << std::endl;

    file << "# Vars" << std::endl;
    file << "SRC_FILES := $(shell find $(SRC_PATH) -name '*." << EXT << "' -type f)" << std::endl;
    file << "OBJECT_FILES := $(addprefix $(OBJECT_PATH)/, $(notdir $(patsubst %." << EXT << ", %.o, $(SRC_FILES))))" << std::endl;
    file << "EXE_BINARY := $(EXE_PATH)/$(EXE_NAME)" << std::endl << std::endl;
    
    file << "# Rules" << std::endl;
    file << ".PHONY : clean" << std::endl << std::endl;

    file << "$(EXE_BINARY): $(OBJECT_FILES) | $(EXE_PATH)" << std::endl;
    file << "\t@echo \"Linking   $@ ...\"" << std::endl;
    file << "\t@$(COMPILER) -o $@ $^ $(LINKER_FLAGS)" << std::endl << std::endl;

    file << "$(EXE_PATH):" << std::endl;
    file << "\t@mkdir -p $@" << std::endl << std::endl;

    file << "$(OBJECT_PATH)/%.o: %." << EXT << " | $(OBJECT_PATH)" << std::endl;
    file << "\t@echo \"Compiling $< ...\"" << std::endl;
    file << "\t@$(COMPILER) -o $@ -c $< $(COMPILER_FLAGS)" << std::endl << std::endl;

    file << "$(OBJECT_PATH):" << std::endl;
    file << "\t@mkdir -p $@" << std::endl << std::endl;

    file << "clean:" << std::endl;
    file << "\t@echo \"Cleaning up ...\"" << std::endl;
    file << "\t@rm $(EXE_BINARY) $(OBJECT_PATH)/*.o";

    file.close();
}

int main() {
    read_config();
    generate_makefile();

    return 0;
}
