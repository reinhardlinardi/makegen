/* 
   makegen.cpp
   > g++ makegen.cpp -o makegen -std=c++11
*/

#include <iostream>
#include <fstream>
#include <string>
#include <regex>


const std::string MAKEFILE = "Makefile";
const std::string CONFIG = "makegen.conf";
const std::string DELIMITER = "=";


std::string LANGUAGE; // c or c++
std::string STANDARD; // e.g. c99, c++11

std::string SRC_ROOT = "src"; // source root
std::string HEADER_ROOT = ""; // header root (gcc/g++ -I)

std::string COMPILER; // e.g. gcc, g++, clang, clang++
bool DEBUG = true; // -g
bool OPTIMIZE = false; // -O2
std::string COMPILER_FLAGS = ""; // e.g. -Wall
std::string LINKER_FLAGS = ""; // e.g. -lm

std::string OBJECT_PATH = "."; // object files path
std::string EXE_PATH = "."; // executable path
std::string EXE_NAME = "main"; // executable name


std::string remove_spaces(std::string s) {
    return std::regex_replace(std::regex_replace(s, std::regex("^\\s*"), ""), std::regex("\\s*$"), "");
}

std::string replace_spaces(std::string s) {
    return std::regex_replace(s, std::regex("\\s+"), " ");
}

std::string remove_path_slash(std::string s) {
    return std::regex_replace(s, std::regex("/$"), "");
}

void read_language(std::string val) {
    if(val != "c" && val != "c++") {
        std::cout << std::endl << "error: LANGUAGE invalid";
        exit(1);
    }
    LANGUAGE = val == "c"? "c" : "c++";
}

void read_standard(std::string val) {
    if(val != "") COMPILER_FLAGS += " -std=" + val;
}

void read_src_root(std::string val) {
    if(val != "") SRC_ROOT = remove_path_slash(val);
}

void read_header_root(std::string val) {
    val = remove_path_slash(val);
    if(val != "") {
        COMPILER_FLAGS += " -I" + val;
        HEADER_ROOT = val;
    }
}

void read_compiler(std::string val) {
    if(val == "") COMPILER = LANGUAGE == "c"? "gcc" : "g++";
}

void read_debug(std::string val) {
    if(val != "false" && val != "true" && val != "") {
        std::cout << std::endl << "error: DEBUG invalid";
        exit(1);
    }

    DEBUG = val == "false"? false : true;
    if(DEBUG) COMPILER_FLAGS += " -g";
}

void read_optimize(std::string val) {
    if(val != "false" && val != "true" && val != "") {
        std::cout << std::endl << "error: OPTIMIZE invalid";
        exit(1);
    }

    OPTIMIZE = val == "true"? true : false;
    if(OPTIMIZE) COMPILER_FLAGS += " -O2";
}

void read_compiler_flags(std::string val) {
    COMPILER_FLAGS += " " + replace_spaces(val);
}

void read_linker_flags(std::string val) {
    LINKER_FLAGS = replace_spaces(val);
}

void read_object_path(std::string val) {
    if(val != "") OBJECT_PATH = remove_path_slash(val);
}

void read_exe_path(std::string val) {
    if(val != "") EXE_PATH = remove_path_slash(val);
}

void read_exe_name(std::string val) {
    if(val != "") EXE_NAME = val;
}

void read_config() {
    std::cout << "Reading config file ...";

    std::fstream file;
    file.open(CONFIG, std::fstream::in);
    if(file.fail()) {    
        std::cout << " file missing or failed to open file.";
        exit(1);
    }

    std::string line;
    while(getline(file, line)) {
        size_t delimiter_idx = line.find(DELIMITER);

        if(delimiter_idx != line.npos) {
            std::string name = line.substr(0, delimiter_idx);
            name = remove_spaces(name);

            std::string val = line.substr(delimiter_idx+1, line.length()-1);
            val = remove_spaces(val);

            if(name == "LANGUAGE") read_language(val);
            else if(name == "STANDARD") read_standard(val);
            else if(name == "SRC_ROOT") read_src_root(val);
            else if(name == "HEADER_ROOT") read_header_root(val);
            else if(name == "COMPILER") read_compiler(val);
            else if(name == "DEBUG") read_debug(val);
            else if(name == "OPTIMIZE") read_optimize(val);
            else if(name == "COMPILER_FLAGS") read_compiler_flags(val);
            else if(name == "LINKER_FLAGS") read_linker_flags(val);
            else if(name == "OBJECT_PATH") read_object_path(val);
            else if(name == "EXE_PATH") read_exe_path(val);
            else if(name == "EXE_NAME") read_exe_name(val);
        }
    }

    COMPILER_FLAGS = remove_spaces(COMPILER_FLAGS);
    file.close();
}

void generate_makefile() {
    std::cout << std::endl << "Generating makefile ...";

    std::fstream file;
    file.open(MAKEFILE, std::fstream::out);
    if(file.fail()) {
        std::cout << " failed to open file.";
        exit(1);
    }

    std::string EXT = LANGUAGE == "c"? "c" : "cpp";

    file << "# --- Autogenerated by makegen ---" << std::endl << std::endl;

    file << "# Source" << std::endl;
    file << "SRC_ROOT := " << SRC_ROOT << std::endl;
    file << "SRC_DIRS := $(shell find $(SRC_ROOT) -type d)" << std::endl;
    file << "SRC_FILES := $(shell find $(SRC_ROOT) -name '*." << EXT << "' -type f)" << std::endl << std::endl;

    file << "# Build" << std::endl;
    file << "COMPILER := " << COMPILER << std::endl;
    file << "COMPILER_FLAGS := " << COMPILER_FLAGS << std::endl;
    file << "LINKER_FLAGS := " << LINKER_FLAGS << std::endl << std::endl;

    file << "# Output" << std::endl;
    file << "OBJECT_PATH := " << OBJECT_PATH << std::endl;
    file << "EXE_PATH := " << EXE_PATH << std::endl;
    file << "EXE_NAME := " << EXE_NAME << std::endl;
    file << "OBJECT_FILES := $(addprefix $(OBJECT_PATH)/, $(notdir $(patsubst %." << EXT << ", %.o, $(SRC_FILES))))" << std::endl;
    file << "EXE_BINARY := $(EXE_PATH)/$(EXE_NAME)" << std::endl << std::endl;
    
    file << "# Rules" << std::endl;
    file << ".PHONY : clean" << std::endl;
    file << "VPATH = $(SRC_DIRS)" << std::endl << std::endl;

    file << "$(EXE_BINARY): $(OBJECT_FILES) | $(EXE_PATH)" << std::endl;
    file << "\t@echo \"Linking   $@ ...\"" << std::endl;
    file << "\t@$(COMPILER) -o $@ $^ $(LINKER_FLAGS)" << std::endl << std::endl;

    file << "$(EXE_PATH):" << std::endl;
    file << "\t@mkdir -p $@" << std::endl << std::endl;

    file << "$(OBJECT_PATH)/%.o: %." << EXT << " | $(OBJECT_PATH)" << std::endl;
    file << "\t@echo \"Compiling $< ...\"" << std::endl;
    file << "\t@$(COMPILER) -o $@ -c $< $(COMPILER_FLAGS)" << std::endl << std::endl;

    file << "$(OBJECT_PATH):" << std::endl;
    file << "\t@mkdir -p $@" << std::endl << std::endl;

    file << "clean:" << std::endl;
    file << "\t@echo \"Cleaning up ...\"" << std::endl;
    file << "\t@rm $(EXE_BINARY) $(OBJECT_PATH)/*.o";

    file.close();
}

int main() {
    read_config();
    generate_makefile();

    return 0;
}
